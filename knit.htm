<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KNIT Pattern Grid</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      max-width: 900px;
    }

    .controls {
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    label {
      margin-right: 4px;
    }

    input[type="number"] {
      width: 70px;
    }

    button {
      padding: 4px 10px;
      cursor: pointer;
      margin-right: 4px;
      margin-top: 4px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    #lockColourToggle.locked {
      background-color: #eee;
      border: 1px solid #999;
    }
    #lockWhiteToggle.locked {
      background-color: #eee;
      border: 1px solid #999;
    }

    table {
      border-collapse: collapse;
      margin-top: 12px;
    }

    td {
      min-width: 22px;
      height: 22px;
      text-align: center;
      border: 1px solid #ddd;
      font-size: 11px;
      background-color: white;
      transition: background-color 0.15s ease, opacity 0.15s ease, filter 0.15s ease;
      cursor: pointer;
      user-select: none;
    }

    .header-cell {
      background-color: #f9f9f9;
      font-weight: 500;
    }

    /* Rows below selected (light dim) */
    tr.row-dim-below td {
      opacity: 0.45;
    }

    /* Rows above selected (dark dim) */
    tr.row-dim-above td {
      opacity: 1;
      filter: brightness(0.25);
    }

    /* Column dimming */
    td.col-dim {
      opacity: 0.4;
    }

    .bold-right {
      border-right-width: 2px !important;
      border-right-color: #555 !important;
    }

    .bold-bottom {
      border-bottom-width: 2px !important;
      border-bottom-color: #555 !important;
    }

    .notes-container {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #patternNotes {
      width: 100%;
      min-height: 70px;
      font-family: inherit;
      font-size: 13px;
      padding: 4px;
      box-sizing: border-box;
    }

    .palette-wrapper {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .palette-label {
      font-size: 12px;
      margin-right: 4px;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .palette-swatch {
      width: 18px;
      height: 18px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      cursor: pointer;
    }

    .palette-swatch.selected {
      outline: 2px solid #000;
      outline-offset: 1px;
    }

    .io-buttons {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .small-label {
      font-size: 11px;
      color: #555;
    }
  </style>
</head>
<body>
  <h2>KNIT Pattern Grid</h2>

  <div class="controls">
    <label for="widthInput">Width:</label>
    <input type="number" id="widthInput" min="1" value="20" />

    <label for="heightInput">Height:</label>
    <input type="number" id="heightInput" min="1" value="20" />

    <button type="button" onclick="generateTable()">Generate Table</button>
    <button type="button" onclick="clearColours()">Clear pattern</button>
    <button type="button" id="undoButton" onclick="undoLastChange()" disabled>Undo last change</button>
    <button type="button" onclick="clearSelection()">Clear ruler</button>
    <button type="button" id="lockColourToggle" onclick="toggleColourLock()">Lock Colours</button>
    <button type="button" id="lockWhiteToggle" onclick="toggleWhiteLock()">Lock White Squares</button>
  </div>

  <div class="palette-wrapper">
    <span class="palette-label">Colour:</span>
    <div class="palette" id="palette"></div>
    <button type="button" id="editColourButton" onclick="openColorEditor()">Edit colour</button>
    <input
      type="color"
      id="colourPicker"
      style="display:none; width:24px; height:24px; border:none; padding:0; margin:0;"
    />
    <span class="small-label">(click swatch, then click or drag over cells)</span>
  </div>

  <div class="notes-container">
    <label for="patternNotes">Pattern notes / details:</label>
    <textarea id="patternNotes" placeholder="Yarn, gauge, repeats, notes..."></textarea>
  </div>

  <div class="io-buttons">
    <button type="button" onclick="downloadPattern()">Download Pattern (JSON)</button>
    <button type="button" onclick="document.getElementById('uploadInput').click()">Upload Pattern (JSON)</button>
    <input type="file" id="uploadInput" accept="application/json" style="display:none" onchange="handleUpload(this.files)" />
  </div>

  <div id="tableContainer"></div>

  <script>
    const STORAGE_KEY = 'gridDesignV5';

    const PALETTE = [
      '#ffffff', '#000000', '#ff0000', '#00ff00',
      '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
      '#ffa500', '#800080', '#ffc0cb', '#a52a2a',
      '#808080', '#00ced1', '#8a2be2', '#006400'
    ];

    // Mutable, persisted palette
    let currentPalette = PALETTE.slice();

    let currentWidth = null;
    let currentHeight = null;
    let currentSelectedRowNumber = null; // bottom-based
    let currentSelectedColNumber = null; // right-based
    let isColourLocked = false;
    let isWhiteLocked = false;
    let currentColor = '#000000';

    let isDragging = false;
    let lastDragCellKey = null;

    let historyStack = [];

    function updateUndoUI() {
      const btn = document.getElementById('undoButton');
      if (!btn) return;
      btn.disabled = historyStack.length === 0;
    }

    function pushHistoryIfPossible() {
      if (!currentWidth || !currentHeight) return;
      const design = buildDesignObject(currentWidth, currentHeight);
      // Deep clone to avoid later mutations
      const clone = JSON.parse(JSON.stringify(design));
      historyStack.push(clone);
      updateUndoUI();
    }

    function undoLastChange() {
      if (!currentWidth || !currentHeight) return;
      if (historyStack.length === 0) return;
      const previous = historyStack.pop();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(previous));
      document.getElementById('widthInput').value = previous.width;
      document.getElementById('heightInput').value = previous.height;
      currentWidth = previous.width;
      currentHeight = previous.height;
      currentColor = previous.currentColor || currentColor;
      if (Array.isArray(previous.palette)) {
        currentPalette = previous.palette.slice();
      } else {
        currentPalette = PALETTE.slice();
      }
      initPalette();
      generateTable();
      updateUndoUI();
    }

    function applyColorToCell(td, color) {
      td.dataset.color = color;
      if (!color || color === '#ffffff' || color.toLowerCase() === 'white') {
        td.style.backgroundColor = 'white';
      } else {
        td.style.backgroundColor = color;
      }
    }

    function buildDesignObject(width, height) {
      const table = document.querySelector('#tableContainer table');
      let coloredCells = [];
      if (table) {
        const dataCells = table.querySelectorAll('td[data-type="data"]');
        dataCells.forEach(td => {
          const color = td.dataset.color || '#ffffff';
          if (color && color !== '#ffffff' && color.toLowerCase() !== 'white') {
            coloredCells.push({
              r: parseInt(td.dataset.row, 10),
              c: parseInt(td.dataset.col, 10),
              color: color
            });
          }
        });
      }
      const notes = document.getElementById('patternNotes').value || '';
      return {
        width,
        height,
        coloredCells,
        selectedRowNumber: currentSelectedRowNumber,
        selectedColNumber: currentSelectedColNumber,
        isColourLocked,
        isWhiteLocked,
        notes,
        currentColor,
        palette: currentPalette
      };
    }

    function saveDesign(width, height) {
      const design = buildDesignObject(width, height);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(design));
    }

    function applyRowSelectionByRowNumber(rowNumber, height) {
      currentSelectedRowNumber = rowNumber;

      const table = document.querySelector('#tableContainer table');
      if (!table) return;

      const rows = table.querySelectorAll('tr');
      rows.forEach(tr => {
        tr.classList.remove('row-dim-below', 'row-dim-above');
      });

      if (!rowNumber) return;

      for (let r = 1; r <= height; r++) {
        const tr = rows[r];
        if (!tr) continue;
        const rowNum = height - r + 1; // bottom-based
        if (rowNum === rowNumber) continue;
        else if (rowNum < rowNumber) tr.classList.add('row-dim-below');
        else tr.classList.add('row-dim-above');
      }
    }

    function applyColumnSelectionByColNumber(colNumber, width, height) {
      currentSelectedColNumber = colNumber;

      const table = document.querySelector('#tableContainer table');
      if (!table) return;

      const dataCells = table.querySelectorAll('td[data-type="data"]');
      dataCells.forEach(td => td.classList.remove('col-dim'));

      if (!colNumber) return;

      const selectedColIndex = width - colNumber + 1;

      dataCells.forEach(td => {
        const c = parseInt(td.dataset.col, 10);
        if (c !== selectedColIndex) {
          td.classList.add('col-dim');
        }
      });
    }

    function loadDesign(width, height) {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (!saved) return;

      let design;
      try {
        design = JSON.parse(saved);
      } catch (e) {
        return;
      }

      if (!design || design.width !== width || design.height !== height) return;

      const table = document.querySelector('#tableContainer table');
      if (!table) return;

      if (typeof design.notes === 'string') {
        document.getElementById('patternNotes').value = design.notes;
      }

      if (typeof design.isColourLocked === 'boolean') {
        isColourLocked = design.isColourLocked;
      } else if (typeof design.isLocked === 'boolean') {
        // Backwards compatibility with older saves that used a global lock
        isColourLocked = design.isLocked;
      }
      if (typeof design.isWhiteLocked === 'boolean') {
        isWhiteLocked = design.isWhiteLocked;
      }

      if (typeof design.currentColor === 'string') {
        currentColor = design.currentColor;
      }

      if (Array.isArray(design.coloredCells)) {
        design.coloredCells.forEach(pos => {
          const selector =
            `td[data-type="data"][data-row="${pos.r}"][data-col="${pos.c}"]`;
          const cell = table.querySelector(selector);
          if (cell) applyColorToCell(cell, pos.color);
        });
      } else if (Array.isArray(design.activeCells)) {
        design.activeCells.forEach(pos => {
          const selector =
            `td[data-type="data"][data-row="${pos.r}"][data-col="${pos.c}"]`;
          const cell = table.querySelector(selector);
          if (cell) applyColorToCell(cell, '#ff0000');
        });
      }

      if (typeof design.selectedRowNumber === 'number') {
        applyRowSelectionByRowNumber(design.selectedRowNumber, height);
      }
      if (typeof design.selectedColNumber === 'number') {
        applyColumnSelectionByColNumber(design.selectedColNumber, width, height);
      }

      if (Array.isArray(design.palette)) {
        currentPalette = design.palette.slice();
        initPalette();
      }

      updateColourLockUI();
      updateWhiteLockUI();
      updatePaletteSelection(currentColor);
    }

    function generateTable() {
      const width = parseInt(document.getElementById('widthInput').value, 10);
      const height = parseInt(document.getElementById('heightInput').value, 10);

      if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
        alert('Please enter positive integers for width and height.');
        return;
      }

      if (currentWidth && currentHeight) {
        pushHistoryIfPossible();
      }

      currentWidth = width;
      currentHeight = height;
      currentSelectedRowNumber = null;
      currentSelectedColNumber = null;

      const tableContainer = document.getElementById('tableContainer');
      tableContainer.innerHTML = '';

      const table = document.createElement('table');

      const totalRows = height + 2;
      const totalCols = width + 2;

      for (let r = 0; r < totalRows; r++) {
        const tr = document.createElement('tr');

        for (let c = 0; c < totalCols; c++) {
          const td = document.createElement('td');
          td.id = `cell-r${r}-c${c}`;

          const isTopHeaderRow = (r === 0);
          const isBottomHeaderRow = (r === totalRows - 1);
          const isLeftHeaderCol = (c === 0);
          const isRightHeaderCol = (c === totalCols - 1);

          const inDataRowRange = (r >= 1 && r <= height);
          const inDataColRange = (c >= 1 && c <= width);

          let rowNumber = null;
          let colNumber = null;

          if (inDataRowRange) rowNumber = height - r + 1;
          if (inDataColRange) colNumber = width - c + 1;

          if ((isTopHeaderRow || isBottomHeaderRow) && inDataColRange) {
            td.textContent = width - c + 1;
            td.classList.add('header-cell');
            td.dataset.type = 'header-col';
            td.style.cursor = 'pointer';

            td.addEventListener('click', () => {
              const colNum = width - c + 1;
              if (currentSelectedColNumber === colNum) {
                applyColumnSelectionByColNumber(null, width, height);
              } else {
                applyColumnSelectionByColNumber(colNum, width, height);
              }
              saveDesign(currentWidth, currentHeight);
            });
          }

          if ((isLeftHeaderCol || isRightHeaderCol) && inDataRowRange) {
            td.textContent = height - r + 1;
            td.classList.add('header-cell');
            td.dataset.type = 'header-row';
            td.style.cursor = 'pointer';

            td.addEventListener('click', () => {
              const rowNum = height - r + 1;
              if (currentSelectedRowNumber === rowNum) {
                applyRowSelectionByRowNumber(null, height);
              } else {
                applyRowSelectionByRowNumber(rowNum, height);
              }
              saveDesign(currentWidth, currentHeight);
            });
          }

          if ((isTopHeaderRow || isBottomHeaderRow) &&
              (isLeftHeaderCol || isRightHeaderCol)) {
            td.textContent = '';
            td.classList.add('header-cell');
            td.dataset.type = 'corner';
            td.style.cursor = 'default';
          }

          if (inDataRowRange && inDataColRange) {
            td.dataset.type = 'data';
            td.dataset.row = r.toString();
            td.dataset.col = c.toString();
            td.dataset.color = '#ffffff';
            td.style.backgroundColor = 'white';

            td.addEventListener('mousedown', (e) => {
              if (e.button !== 0) return;
              e.preventDefault();
              startDragOnCell(td);
            });

            td.addEventListener('mouseenter', () => {
              applyDragToCell(td);
            });

            td.addEventListener('touchstart', (e) => {
              e.preventDefault();
              startDragOnCell(td);
            }, { passive: false });
          }

          if (inDataColRange && colNumber !== null &&
              (colNumber === 1 || (colNumber > 1 && (colNumber - 1) % 10 === 0))) {
            td.classList.add('bold-right');
          }

          if (inDataRowRange && rowNumber !== null &&
              (rowNumber === 1 || (rowNumber > 1 && (rowNumber - 1) % 10 === 0))) {
            td.classList.add('bold-bottom');
          }

          tr.appendChild(td);
        }

        table.appendChild(tr);
      }

      tableContainer.appendChild(table);

      loadDesign(width, height);
    }

    function startDragOnCell(td) {
      if (td.dataset.type !== 'data') return;
      pushHistoryIfPossible();
      isDragging = true;
      lastDragCellKey = null;
      applyDragToCell(td);
    }

    function applyDragToCell(td) {
      if (!isDragging || !td || td.dataset.type !== 'data') return;
      const key = td.dataset.row + ':' + td.dataset.col;
      if (key === lastDragCellKey) return;
      lastDragCellKey = key;

      const current = td.dataset.color || '#ffffff';
      const isWhite = (current === '#ffffff' || current.toLowerCase() === 'white');

      // White cells obey white-lock only
      if (isWhite && isWhiteLocked) {
        return;
      }

      // Coloured cells obey colour-lock only
      if (!isWhite && isColourLocked) {
        return;
      }

      // Always apply the currently selected palette colour
      applyColorToCell(td, currentColor);
    }

    function endDrag() {
      if (!isDragging) return;
      isDragging = false;
      lastDragCellKey = null;
      if (currentWidth && currentHeight) {
        saveDesign(currentWidth, currentHeight);
      }
    }

    window.addEventListener('mouseup', endDrag);
    window.addEventListener('mouseleave', endDrag);

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      const touch = e.touches[0];
      if (!touch) return;
      const el = document.elementFromPoint(touch.clientX, touch.clientY);
      if (el && el.dataset && el.dataset.type === 'data') {
        applyDragToCell(el);
      }
    }, { passive: true });

    document.addEventListener('touchend', endDrag);
    document.addEventListener('touchcancel', endDrag);

    function clearColours() {
      const table = document.querySelector('#tableContainer table');
      if (!table) return;
      if (!confirm('Clear the entire pattern?')) return;
      pushHistoryIfPossible();
      const dataCells = table.querySelectorAll('td[data-type="data"]');
      dataCells.forEach(td => applyColorToCell(td, '#ffffff'));
      if (currentWidth && currentHeight) saveDesign(currentWidth, currentHeight);
    }

    function clearSelection() {
      if (!currentWidth || !currentHeight) return;
      pushHistoryIfPossible();
      applyRowSelectionByRowNumber(null, currentHeight);
      applyColumnSelectionByColNumber(null, currentWidth, currentHeight);
      saveDesign(currentWidth, currentHeight);
    }

    function toggleColourLock() {
      if (!currentWidth || !currentHeight) {
        isColourLocked = !isColourLocked;
        updateColourLockUI();
        return;
      }
      pushHistoryIfPossible();
      isColourLocked = !isColourLocked;
      updateColourLockUI();
      saveDesign(currentWidth, currentHeight);
    }

    function updateColourLockUI() {
      const btn = document.getElementById('lockColourToggle');
      if (!btn) return;
      btn.textContent = isColourLocked ? 'Unlock Colours' : 'Lock Colours';
      btn.classList.toggle('locked', isColourLocked);
    }

    function updateWhiteLockUI() {
      const btn = document.getElementById('lockWhiteToggle');
      if (!btn) return;
      btn.textContent = isWhiteLocked ? 'Unlock White Squares' : 'Lock White Squares';
      btn.classList.toggle('locked', isWhiteLocked);
    }

    function toggleWhiteLock() {
      if (!currentWidth || !currentHeight) {
        isWhiteLocked = !isWhiteLocked;
        updateWhiteLockUI();
        return;
      }
      pushHistoryIfPossible();
      isWhiteLocked = !isWhiteLocked;
      updateWhiteLockUI();
      saveDesign(currentWidth, currentHeight);
    }

    function initPalette() {
      const paletteDiv = document.getElementById('palette');
      paletteDiv.innerHTML = '';
      currentPalette.forEach(color => {
        const sw = document.createElement('div');
        sw.className = 'palette-swatch';
        sw.style.backgroundColor = color;
        sw.dataset.color = color;
        sw.addEventListener('click', () => {
          currentColor = color;
          updatePaletteSelection(color);
          if (currentWidth && currentHeight) saveDesign(currentWidth, currentHeight);
        });
        paletteDiv.appendChild(sw);
      });
      updatePaletteSelection(currentColor);
    }

    function updatePaletteSelection(color) {
      const swatches = document.querySelectorAll('.palette-swatch');
      swatches.forEach(sw => {
        if (sw.dataset.color === color) {
          sw.classList.add('selected');
        } else {
          sw.classList.remove('selected');
        }
      });
    }

    function openColorEditor() {
      // Do not allow editing of white
      if (currentColor === '#ffffff' || currentColor.toLowerCase() === 'white') {
        alert('White cannot be edited. Please select a different colour first.');
        return;
      }
      const picker = document.getElementById('colourPicker');
      if (!picker) return;
      // Initialise picker with the current colour (fallback to black if invalid)
      try {
        picker.value = currentColor && /^#([0-9a-fA-F]{6})$/.test(currentColor)
          ? currentColor
          : '#000000';
      } catch (e) {
        picker.value = '#000000';
      }
      // Show the colour input so the user can click it (Safari-friendly)
      picker.style.display = 'inline-block';
      picker.focus();
    }

    function handleColourPickerChange(event) {
      const newColor = event.target.value;
      if (!newColor) return;

      // Update the currently selected swatch to use the new colour
      const swatches = document.querySelectorAll('.palette-swatch');
      swatches.forEach((sw, index) => {
        if (sw.classList.contains('selected')) {
          sw.dataset.color = newColor;
          sw.style.backgroundColor = newColor;
          if (Array.isArray(currentPalette) && index < currentPalette.length) {
            currentPalette[index] = newColor;
          }
        }
      });

      // Update current colour and selection highlight
      currentColor = newColor;
      updatePaletteSelection(newColor);

      // Persist the fact we've changed the currently selected colour
      if (currentWidth && currentHeight) {
        saveDesign(currentWidth, currentHeight);
      } else {
        // Also persist palette for next session even before a grid exists
        const scratchDesign = {
          width: parseInt(document.getElementById('widthInput').value, 10) || 20,
          height: parseInt(document.getElementById('heightInput').value, 10) || 20,
          coloredCells: [],
          selectedRowNumber: null,
          selectedColNumber: null,
          isColourLocked,
          isWhiteLocked,
          notes: document.getElementById('patternNotes').value || '',
          currentColor,
          palette: currentPalette
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(scratchDesign));
      }
      // Hide the colour picker again after selection
      const picker = document.getElementById('colourPicker');
      if (picker) {
        picker.style.display = 'none';
      }
    }

    function downloadPattern() {
      if (!currentWidth || !currentHeight) {
        alert('Generate a grid first.');
        return;
      }
      const design = buildDesignObject(currentWidth, currentHeight);
      const blob = new Blob([JSON.stringify(design, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `knit-pattern-${design.width}x${design.height}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function handleUpload(files) {
      if (!files || !files[0]) return;
      const file = files[0];
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const design = JSON.parse(e.target.result);
          if (!design.width || !design.height) {
            alert('Invalid pattern file (missing width/height).');
            return;
          }
          if (currentWidth && currentHeight) {
            pushHistoryIfPossible();
          }
          if (Array.isArray(design.palette)) {
            currentPalette = design.palette.slice();
          } else {
            currentPalette = PALETTE.slice();
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify(design));
          document.getElementById('widthInput').value = design.width;
          document.getElementById('heightInput').value = design.height;
          currentColor = design.currentColor || currentColor;
          initPalette();
          generateTable();
        } catch (err) {
          alert('Could not read pattern file.');
        }
      };
      reader.readAsText(file);
    }

    window.addEventListener('load', () => {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          const design = JSON.parse(saved);
          if (design && design.width && design.height) {
            document.getElementById('widthInput').value = design.width;
            document.getElementById('heightInput').value = design.height;
            if (typeof design.currentColor === 'string') {
              currentColor = design.currentColor;
            }
            if (Array.isArray(design.palette)) {
              currentPalette = design.palette.slice();
            }
            if (typeof design.isColourLocked === 'boolean') {
              isColourLocked = design.isColourLocked;
            } else if (typeof design.isLocked === 'boolean') {
              isColourLocked = design.isLocked;
            }
            if (typeof design.isWhiteLocked === 'boolean') {
              isWhiteLocked = design.isWhiteLocked;
            }
          }
        } catch (e) {}
      }

      initPalette();

      const colourPicker = document.getElementById('colourPicker');
      if (colourPicker) {
        colourPicker.addEventListener('input', handleColourPickerChange);
        colourPicker.addEventListener('change', handleColourPickerChange);
      }

      const notesEl = document.getElementById('patternNotes');
      notesEl.addEventListener('input', () => {
        if (currentWidth && currentHeight) {
          saveDesign(currentWidth, currentHeight);
        }
      });

      generateTable();
      updateUndoUI();
    });
  </script>
</body>
</html>